/*
 * main.c
 *
 *  Created on: 16/09/2014
 *      Author: Nicolas Florio
 *
 *    WAV Player
 */

// *************************************************************************************
// Includes
// *************************************************************************************
#include <avr/interrupt.h>
#include <avr/iom128.h>
#include <avr/pgmspace.h>
#include <avr/sfr_defs.h>
#include <string.h>

#include "diskio.h"
#include "ff.h"
#include "integer.h"
#include "lcd_alfa.h"
#include "rtc.h"
#include "Timer0.h"
#include "Timer1.h"
#include "xitoa.h"

// *************************************************************************************
// Macros
// *************************************************************************************
#define get_SW(bit) !(PINE&(1<<bit))

// *************************************************************************************
// Defines
// *************************************************************************************
#define SW1 5
#define SW2 6
#define SW3 7
#define TRUE 1
#define FALSE 0
#define EXIT_SUCCESS 0
#define EXIT_FAILURE !EXIT_SUCCESS
#define WAV_OK 1
#define BUFF_SIZE 512
#define MAX_FILES 50
//#define DEBUG

// *************************************************************************************
// Typedefs
// *************************************************************************************
typedef struct header
{
    char      chunk_id[4];
    long  int chunk_size;
    char      format[4];
    char      subchunk1_id[4];
    long  int subchunk1_size;
    short int audio_format;
    short int num_channels;
    long  int sample_rate;
    long  int byte_rate;
    short int block_align;
    short int bits_per_sample;
    char      subchunk2_id[4];
    long  int subchunk2_size;
} header_t;

// *************************************************************************************
// Variables globales
// *************************************************************************************
FATFS   Fat;		                    /* File system object for each logical drive */
FIL     File;	                        /* File object */
DIR     Dir;		                    /* Directory object */
FILINFO Fileinfo;                       /* File information */

BYTE  RtcOk;				            /* RTC is available */
volatile UINT Timer;		            /* Performance timer (100Hz increment) */

// Variables para el archivo WAV
header_t WAV_header;                    /* Encabezado del archivo WAV */
UINT     WAV_samples[2][BUFF_SIZE];     /* Buffers */
volatile UINT buffer = 0,               /* El Buffer que estoy reproduciendo */
              sample = 0,               /* La muestra actual que mando a OCR0 */
              upd_buffer = FALSE;       /* Flag para actualizar el buffer */
char     WAV_files[MAX_FILES][13];      /* Guardo los nombres de los archivos */
UINT     files_ctr;                     /* Cuanto la cantidad de archivos cargados */

// *************************************************************************************
// Implementacion de las interrupciones
// *************************************************************************************
ISR(TIMER1_COMPA_vect)
{
	OCR0 = WAV_samples[buffer][sample++];

	// Cuando termino de procesar el buffer, entonces voy al inicio del otro buffer y activo el flag upd_buffer
	if(sample == BUFF_SIZE){
		sample     = 0;
		upd_buffer = TRUE;
		buffer     = !buffer;
	}
}

/*-------------------------------------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                                              */
/*-------------------------------------------------------------------------------------*/
ISR(TIMER2_COMP_vect)
{
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}

// *************************************************************************************
// Prototipo de funciones
// *************************************************************************************
DWORD get_fattime (void);
static void ioinit (void);
void init(void);
void init_LCD(void);
void init_SD(void);
void init_TIMERS(void);
void init_PORTS(void);
void show_LCD_error(char *);
void play_WAV(char *);
UINT open_WAV(char *);
void close_WAV(void);
UINT load_buffer(UINT bf);
UINT check_WAV(void);
void show_FatFs_error(int error);
void start_timer(void);
void stop_timer(void);
void load_WAV_files(void);
UINT select_WAV(UINT file);
void show_file(UINT file);

// *************************************************************************************
//                                     M  A  I  N
// *************************************************************************************
int main (void)
{
	UINT file=0;

	init();

	while(TRUE){
		file = select_WAV(file);
		play_WAV(WAV_files[file]);
	};

	return EXIT_SUCCESS;
}

// *************************************************************************************
// Implementacion de las funciones
// *************************************************************************************
void init(void)
{
	ioinit();    /* Initialize port settings and start system timer process */
	init_LCD();
	init_SD();
	init_TIMERS();
	init_PORTS();
	load_WAV_files();
}

void init_LCD(void)
{
	lcd_init(LCD_DISP_ON);	// Inicializo el display
    lcd_puts("INICIANDO...");
    lcd_gotoxy(1,0);
}

void init_SD(void)
{
	UINT res;
	BYTE sd_status;

	sd_status = disk_initialize(0);		// Inicializo la memoria SD

	if (sd_status & STA_NODISK)
	     show_LCD_error("\nNO HAY TARJETA!");
	else
	{
	     if (sd_status & STA_NOINIT)
	    	 show_LCD_error("\nFALLA EN LA SD!");
	     else
	          if (sd_status & STA_PROTECT)
	        	  show_LCD_error("\nSD PROTEGIDA!");
	          else
	        	  lcd_puts("\nSD OK!");
	}

	res = f_mount(&Fat, "", 0);
	if(res == FR_OK)
		lcd_puts("Unidad montada");
	else{
		show_FatFs_error(res);
		while(TRUE);
	}
}

void init_TIMERS(void)
{
	// Configuro los Timers
	Timer0_init(Fast_PWM, Timer0_Prescaler_1, PWM_Invert);
	Timer1_init(CTC_OCR1A,
			    Timer1_Prescaler_1,
			    Timer1_Toggle_On_Comp_Match,
			    Timer1_Disconected,
			    Timer1_Disconected);
}

void init_PORTS(void)
{
	DDRD  = 0xF0; // Puerto D como salida (LEDS 1-4)
	PORTD = 0xF0; // Apago los leds
}

void show_LCD_error(char *str)
{
	lcd_clrscr();
	lcd_gotoxy(0,0);
	lcd_puts("-- E R R O R --");
	lcd_puts(str);
	while(TRUE);
}

void play_WAV(char *filename)
{
	UINT i;

	if(open_WAV(filename) == TRUE) {      // Abro el WAV
		if(check_WAV() == WAV_OK) {       // Chequeo que sea un archivo WAV
			if(load_buffer(buffer)) {     // Cargo el primer buffer
				start_timer();            // Empiezo a reproducir el audio

				for(i = 0; i < (WAV_header.subchunk2_size/(BUFF_SIZE*2)); i++)
				{
					load_buffer(!buffer);       // Cargo el buffer que no estoy reproduciendo
					while(upd_buffer == FALSE); // Espero que me pidan actualizar el buffer
				}

				stop_timer();  // Termino...
			}
		}
		
		close_WAV();           // Cierro el WAV
	}
}

void start_timer(void)
{
	/* NOTA: Cambiar el valor DDRB despues de llamar a f_open por que sino no funca ! */
	DDRB |= _BV(PB4);                       // Seteo el pin OC0  como salida
	OCR1A = 2*F_CPU/WAV_header.sample_rate; // OCR1A tiene que ser el doble
	TIMER1_COMPA_Interrupt_ON;              // Activo la interrupcion del timer1 por comparacion
	sei();                                  // Activo las interrupciones
}

void stop_timer(void)
{
	TIMSK &= ~_BV(OCIE1A);
	PORTD = 0xF0;   // Apago todos los leds
}

UINT open_WAV(char *filename)
{
	// Abro el archivo
	UINT res = f_open(&File, filename, FA_READ|FA_OPEN_EXISTING);

	if(res != FR_OK)
		show_FatFs_error(res);
	
	return !res;
}

void close_WAV(void)
{
	// Cierro el archivo
	UINT res = f_close(&File);
	
	if(res != FR_OK)
		show_FatFs_error(res);
}

UINT load_buffer(UINT bf)
{
	UINT contador, res;

	res = f_read(&File, &WAV_samples[bf], sizeof(WAV_samples[0]), &contador);

	if(res == FR_OK)
		upd_buffer = FALSE;
	else
		show_FatFs_error(res);

	return !res;
}

UINT check_WAV(void)
{
	UINT contador, res;

	// Leo el encabezado del archivo WAV
	res = f_read(&File, &WAV_header, sizeof(header_t), &contador);
	
	if(res == FR_OK)
	{
		if(!strncmp(WAV_header.chunk_id, "RIFF", 4) && !strncmp(WAV_header.format, "WAVE", 4)){
			if(WAV_header.audio_format == 1 && WAV_header.num_channels == 1){
			}
			else{
				lcd_puts("ERROR ARCH");
				res = 1;
			}
		}
		else
			lcd_puts("ERROR WAV");
	}
	else
		show_FatFs_error(res);

	return !res;
}

void show_FatFs_error(int error)
{
	switch(error){
	case FR_DISK_ERR:
		//xputs(PSTR("(1) A hard error occurred in the low level disk I/O layer\n"));
		lcd_puts("ERROR 1");
		break;
	case FR_INT_ERR:
		//xputs(PSTR("(2) Assertion failed\n"));
		lcd_puts("ERROR 2");
		break;
	case FR_NOT_READY:
		//xputs(PSTR("(3) The physical drive cannot work\n"));
		lcd_puts("ERROR 3");
		break;
	case FR_NO_FILE:
		//xputs(PSTR("(4) Could not find the file\n"));
		lcd_puts("ERROR 4");
		break;
	case FR_NO_PATH:
		//xputs(PSTR("(5) Could not find the path\n"));
		lcd_puts("ERROR 5");
		break;
	case FR_INVALID_NAME:
		//xputs(PSTR("(6) The path name format is invalid\n"));
		lcd_puts("ERROR 6");
		break;
	case FR_DENIED:
		//xputs(PSTR("(7) Access denied due to prohibited access or directory full\n"));
		lcd_puts("ERROR 7");
		break;
	case FR_EXIST:
		//xputs(PSTR("(8) Access denied due to prohibited access\n"));
		lcd_puts("ERROR 8");
		break;
	case FR_INVALID_OBJECT:
		//xputs(PSTR("(9) The file/directory object is invalid\n"));
		lcd_puts("ERROR 9");
		break;
	case FR_WRITE_PROTECTED:
		//xputs(PSTR("(10) The physical drive is write protected\n"));
		lcd_puts("ERROR 10");
		break;
	case FR_INVALID_DRIVE:
		//xputs(PSTR("(11) The logical drive number is invalid\n"));
		lcd_puts("ERROR 11");
		break;
	case FR_NOT_ENABLED:
		//xputs(PSTR("(12) The volume has no work area\n"));
		lcd_puts("ERROR 12");
		break;
	case FR_NO_FILESYSTEM:
		//xputs(PSTR("(13) There is no valid FAT volume\n"));
		lcd_puts("ERROR 13");
		break;
	case FR_MKFS_ABORTED:
		//xputs(PSTR("(14) The f_mkfs() aborted due to any parameter error\n"));
		lcd_puts("ERROR 14");
		break;
	case FR_TIMEOUT:
		//xputs(PSTR("(15) Could not get a grant to access the volume within defined period\n"));
		lcd_puts("ERROR 15");
		break;
	case FR_LOCKED:
		//xputs(PSTR("(16) The operation is rejected according to the file sharing policy\n"));
		lcd_puts("ERROR 16");
		break;
	case FR_NOT_ENOUGH_CORE:
		//xputs(PSTR("(17) LFN working buffer could not be allocated\n"));
		lcd_puts("ERROR 17");
		break;
	case FR_TOO_MANY_OPEN_FILES:
		//xputs(PSTR("(18) Number of open files > _FS_SHARE\n"));
		lcd_puts("ERROR 18");
		break;
	case FR_INVALID_PARAMETER:
		//xputs(PSTR("(19) Given parameter is invalid\n"));
		lcd_puts("ERROR 19");
		break;
	default:
		//xputs(PSTR("Error desconocido\n"));
		lcd_puts("ERROR!");
		break;
	}
}

void load_WAV_files(void)
{
	UINT res;
	TCHAR directory[20];

	res = f_getcwd(directory,20);   // Obtengo la ruta del directorio

	if(res == FR_OK){
		res = f_opendir(&Dir, directory);  // Abro el directorio

		if(res == FR_OK){
		   for (files_ctr = 0; files_ctr < MAX_FILES;) {
				res = f_readdir(&Dir, &Fileinfo);
				if (res != FR_OK || Fileinfo.fname[0] == 0) break;  /* Break on error or end of dir */
				if (Fileinfo.fname[0] == '.') continue;             /* Ignore dot entry */

	            if ((Fileinfo.fattrib & AM_ARC) &&                  /* Es un archivo */
	                (Fileinfo.fname[strlen(Fileinfo.fname)-1] == 'V') &&
	                (Fileinfo.fname[strlen(Fileinfo.fname)-2] == 'A') &&
	                (Fileinfo.fname[strlen(Fileinfo.fname)-3] == 'W')) {
	            	strncpy(WAV_files[files_ctr], Fileinfo.fname, (strlen(Fileinfo.fname)));
				    files_ctr++;
	            }
		   }

		   f_closedir(&Dir);
		}
		else
			show_FatFs_error(res);
	}
	else
		show_FatFs_error(res);
}

UINT select_WAV(UINT file)
{
	UINT flag=TRUE;

	if(files_ctr){
		show_file(file);
		while(!get_SW(SW1)){ // SW1 Play
			switch(PINE>>6){
			case 0x01: // SW3 Retrocede
				if((file > 0) && flag){
					flag = FALSE;
					file--;
					show_file(file);
				}
				break;
			case 0x02: // SW2 Avanza
				if((file < files_ctr-1) && flag){
					flag = FALSE;
					file++;
					show_file(file);
				}
				break;
			default:
				flag = TRUE;
				break;
			}
		}
	}
	else
		show_LCD_error("NO HAY ARCHIVOS");

	return file;
}

void show_file(UINT file)
{
	lcd_clrscr();
	lcd_gotoxy(0,0);
	lcd_puts(".:.WAV Player.:.\n");
	lcd_puts(WAV_files[file]);
}
/*---------------------------------------------------------*/
/* User Provided Timer Function for FatFs module           */
/*---------------------------------------------------------*/
/* This is a real time clock service to be called from     */
/* FatFs module. Any valid time must be returned even if   */
/* the system does not support a real time clock.          */
/* This is not required in read-only configuration.        */
DWORD get_fattime (void)
{
	RTC rtc;

	if (!RtcOk) return 0;

	/* Get local time */
	rtc_gettime(&rtc);

	/* Pack date and time into a DWORD variable */
	return	  ((DWORD)(rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| ((DWORD)rtc.hour << 11)
			| ((DWORD)rtc.min << 5)
			| ((DWORD)rtc.sec >> 1);
}
/*--------------------------------------------------------------------------*/

static void ioinit (void)
{
	/* Start 100Hz system timer (TC2.OC) */
	OCR2   = F_CPU / 1024 / 100 - 1;
	TCCR2  = 0b00001101;
	TIMSK |= _BV(OCIE2);

	sei();
}
